@base <http://example.org/> .
@prefix dash: <http://datashapes.org/dash#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix schema: <http://schema.org/> .
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix cube: <https://cube.link/> .
@prefix meta: <https://cube.link/meta/> .
@prefix qudt: <http://qudt.org/schema/qudt/> .

#
# This is the bare minimal SHACL shape for validating a Cube Constraint.
# All Cube Constraints should pass this validation.
#

<ObservationConstraintShape>
    a sh:NodeShape ;
    sh:targetClass cube:Constraint ;
    sh:property [
        # we assume at least 3 dimensions, otherwise we would have an empty list of dimensions
        # one for cube:observedBy, one for rdf:type and at least one cube dimension
        sh:path sh:property ;
        sh:minCount 3 ;
        sh:message "cube:Constraint needs at least a certain amount of sh:properties"
    ] ;
    sh:property [
        sh:path sh:property ;
        sh:node <ObservationConstraintProperty>;
        sh:message "The constraints do not validate"
    ] ;
	sh:property [
        sh:path sh:closed;
        sh:hasValue true;
    ] ;
    sh:property [
        sh:path meta:inHierarchy;
        sh:node <Hierarchy>;
        sh:message "meta:inHierarchy does not validate"
    ] ;
    .

<ObservationConstraintProperty> a sh:NodeShape;
	sh:property [
        sh:path qudt:scaleType;
        sh:in ( qudt:IntervalScale qudt:NominalScale qudt:EnumerationScale qudt:RatioScale qudt:OrdinalScale) ;
        sh:maxCount 1;
	    sh:message "If qudt:scaleType is used it needs to be within ( qudt:IntervalScale qudt:NominalScale qudt:EnumerationScale qudt:RatioScale qudt:OrdinalScale )"
    ];
	sh:property [
        sh:path sh:path;
        sh:minCount 1;
        sh:maxCount 1;
        sh:message "a sh:path is needed on a property"
    ];
    sh:property [
        sh:path sh:minInclusive;
        sh:nodeType sh:Literal;
        sh:message "sh:minInclusive needs to be a literal"
    ];
    sh:property [
        sh:path sh:in;
        sh:node <listnode>;
        sh:message "sh:in needs to be a list"
    ];
    sh:property [
        sh:path sh:maxInclusive;
        sh:nodeType sh:Literal;
        sh:message "sh:maxInclusive needs to be a literal"
    ];
    sh:property [
        sh:path meta:dimensionRelation;
        sh:node <DimensionRelation>;
        sh:message "meta:dimensionRelation does not validate"
    ];

    sh:property [
        sh:message "needs a schema:name" ;
        sh:or(
            [
                sh:path schema:name;
                sh:minCount 1;
                sh:or ( [ sh:datatype xsd:string ] [ sh:datatype rdf:langString ] ) ;
            ]
            [
                sh:path sh:path;
                sh:in (rdf:type cube:observedBy);
            ]
        );
    ];
    
    sh:property [
        sh:message "needs a sh:datatype, sh:nodeKind or sh:datatype within sh:or (...)" ;
        sh:or(
            [
                sh:path sh:datatype;
                sh:minCount 1;
            ]
            [
                sh:path sh:nodeKind;
                sh:minCount 1;
            ]
            [
                sh:path sh:or;
                sh:minCount 1;
                sh:node <listnode> ;
                sh:node [
                    sh:path ( [ sh:zeroOrMorePath rdf:rest ] rdf:first ) ; # all list elements
                    sh:property [ sh:path sh:datatype ; sh:minCount 1 ] ; # have at least one datatype
                ]
            ]
        );
    ] ;

.


<DimensionRelation> a sh:NodeShape ;
    sh:property [
        sh:path meta:relatesTo;
        sh:nodeKind sh:IRI ;
        sh:minCount 1;
        sh:message "meta:dimensionRelation requires at least one meta:relatesTo";
    ] .


# Testing proper rdf:list construction
<listnode> a sh:NodeShape ;
    sh:targetClass rdf:List ;
    sh:property [
        sh:path rdf:first;
        sh:minCount 1;
        sh:maxCount 1;
    ];
    sh:property [
        sh:path rdf:rest;
        sh:minCount 1;
        sh:maxCount 1;
        sh:or (
            [
                sh:node <listnode>;
            ]
            [
                sh:hasValue rdf:nil;
            ]
	    ) ;
        sh:message "a rdf:List can only have one rdf:rest node, multiples nodes need to be linked"
        #sh:node <restnode>;
    ]
    .

<inversepathnode> a sh:NodeShape ;
    sh:property [
        sh:path sh:inversePath;
        sh:nodeKind sh:IRI;
        sh:minCount 1;
        sh:maxCount 1;
        sh:message "nextInHierarchy requires sh:path to be IRI or [ sh:inversePath ... ]"
    ] .

<NextInHierarchy> a sh:NodeShape ;
    sh:property [
        sh:path sh:path;
        sh:minCount 1;
        sh:maxCount 1;
        sh:message "nextInHierarchy requires exactly one sh:path"
    ],
    [
        sh:path schema:name;
        sh:minCount 1;
        sh:message "nextInHierarchy requires schema:name"
    ],
    [
        sh:path sh:targetClass;
        sh:nodeKind sh:IRI;
        sh:message "meta:nextInHierarchy/sh:targetClass must be an IRI"
    ],
    [
        sh:path meta:nextInHierarchy;
        sh:node <NextInHierarchy> ;
        sh:severity sh:Info;
        sh:message "nextInHierarchy can have nested nodes"
    ] ;
    sh:or (
        [
            sh:path sh:path;
	        sh:nodeKind sh:IRI;
            sh:message "nextInHierarchy requires sh:path to be IRI or [ sh:inversePath ... ]"
        ]
        [
            sh:path sh:path;
            sh:nodeKind sh:BlankNode;
            sh:node <inversepathnode>;
            sh:message "nextInHierarchy requires sh:path to be IRI or [ sh:inversePath ... ]"
        ]
    )
    .

<Hierarchy> a sh:NodeShape ;
    sh:targetClass meta:Hierarchy ;
    sh:property [
        sh:path meta:hierarchyRoot;
        sh:minCount 1;
        sh:nodeKind sh:IRI;
        sh:message "inHierarchy requires hierarchyRoot";
    ],
    [
        sh:path schema:name;
        sh:minCount 1;
        sh:message "inHierarchy requires schema:name"
    ],
    [
        sh:path meta:nextInHierarchy;
	    sh:node <NextInHierarchy>;
        sh:minCount 1;
        sh:message "inHierarchy requires a conform nextInHierarchy"
    ] .